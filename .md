# Logicytics Contributors

Contributors are essential to the growth and success of open-source projects like Logicytics.
They come in various forms, each contributing uniquely to enhance the tool's capabilities and user experience.

## Types of Contributors

### 1. Functionality Adders

These contributors introduce new features and functionalities to Logicytics. 
Their contributions often require:

- Deep understanding of the project's architecture
- Innovative thinking to expand software capabilities
- Usually, Collaboration with existing team members to integrate new features seamlessly

Examples of contributions from Functionality Adders might include:

- Implementing new data collection modules
- Developing advanced analysis tools
- Integrating Logicytics with other popular forensic software
- Adding MODS to the project

### 2. Code Cleaners

Code cleaners focus on improving the existing Logicytics codebase. Their contributions typically involve:

- Refactoring complex code structures
- Optimizing performance-critical sections
- Ensuring adherence to Python best practices and coding standards

Code Cleaners play a crucial role in maintaining Logicytics' efficiency and maintainability over time.

### 3. QoL Enhancers

Quality of Life (QoL) enhancers focus on improving the usability and enjoyment of Logicytics 
without necessarily adding new features. Their contributions might include:

- Basic Improvements to enhance user experience
- Streamlining workflows within the application
- Maintaining a clean and intuitive GitHub repository

QoL Enhancers contribute significantly to making Logicytics more accessible and effective for its users.

### 4. Bug Fixers

Bug fixers focus on identifying and resolving issues within the Logicytics codebase. 
Their contributions are crucial for:

- Maintaining stability and reliability of the tool
- Improving overall user experience by eliminating frustrating errors
- Ensuring compatibility across different Windows versions (mostly 10 and 11) and hardware configurations
- Fixes that significantly impact overall performance or stability

### 5. Documentation Specialists

Documentation specialists focus on creating and updating comprehensive documentation for Logicytics. 
Their contributions include:

- Writing clear, concise user guides
- Updating the project's README and wiki pages on every major or minor release
- Maintaining up-to-date release notes and changelogs

Good documentation is essential for onboarding new users and facilitating collaboration among contributors.

**NOTE**: Contributors may fall into multiple categories based on their contributions (Most likely QoL Enhancers), they also may not fall into any.

### 6. Community Supporters

Community supporters contribute by engaging with other users and potential contributors. 
Their activities might include:

- Answering questions on GitHub issues or forums.
- Providing support through issues.

Community supporters help build and sustain interest in the project, 
attracting new contributors and users.

**NOTE**: Contributors may fall into multiple categories based on their contributions, they also may not fall into any.

## Contribution Tips

Logicytics welcomes contributions from individuals with various skill levels and backgrounds. To contribute:

1. Fork the repository on GitHub
2. Choose an area you'd like to contribute to (new feature, bug fix, etc.)
3. Make your changes and commit them
4. Open a pull request describing your contribution
5. Engage with the review process and address any feedback

Remember to follow the project's contributing guidelines and code of conduct when making contributions.

Contributors who wish to register their contributions properly should use the `--dev` flag 
when running Logicytics. 
This ensures proper attribution and tracking of contributions within the project's ecosystem.
Then just follow the instructions [below](#how-to-contribute) to get more specific details.

## How to Contribute

Contributing to open-source projects is a rewarding way to give back to the community
while enhancing your skills. Here's how you can get started:

1. **Fork the Repository**: Visit the project's GitHub page and click on the 'Fork' button in the top right corner. This creates a copy of the repository in your GitHub account.

2. **Clone the Repository**: Clone the forked repository to your local machine using Git. Open your terminal or command prompt and run:
   ```bash
   git clone https://github.com/DefinetlyNotAI/Logicytics.git
   ```
3. **Create a New Branch**: It's good practice to create a new branch for your changes. This keeps the main branch clean and makes merging easier. Run:
   ```bash
   git checkout -b feature/your-feature-description
   ```
   Replace `your-feature-description` with your feature description.

4. **Make Your Changes**: Navigate through the files and make your contributions. Remember to adhere to the project's coding standards and practices outlined below.

5. **Commit Your Changes**: After making your changes, stage them for commit. Then, commit with a meaningful message:
   ```bash
   git add.
   git commit -m "Your descriptive commit message"
   ```

6. **Push Your Changes**: Push your committed changes to your forked repository on GitHub:
   ```bash
   git push origin feature/your-feature-description
   ```

7. **Open a Pull Request (PR)**: Go to your forked repository on GitHub, switch to your feature branch, and click 'New pull request'. Fill out the form, describing your changes and why they should be included. Submit the PR for review.

# Logicytics Coding Standards

When adding new files to the Logicytics project,
it's important to follow consistent guidelines to maintain code quality and ease of maintenance.

Maintaining consistent and readable code is crucial for collaborative development
and long-term maintenance of Logicytics. 
Adhering to these practices ensures that the codebase remains clean, 
efficient, and easy to understand for all contributors.

Here are the 6 foundations of Logicytics coding standards:

## 1. Language Preference

Prefer Python, Batch, or PowerShell scripts for new additions:

- Python: Ideal for complex logic and integrations
- Batch: Suitable for simple Windows-specific tasks
- PowerShell: Good for advanced Windows automation

If using other languages:
- Ensure thorough documentation
- Translate to EXE for compatibility
- Consider using PyInstaller for Python scripts

## 2. File Naming and Organization

Follow these guidelines:

- Place files in appropriate directories based on functionality
- Maintain consistent naming patterns throughout the project
- File Naming: Use lowercase_with_underscores naming convention (e.g., `my_script.py`)
    - If the file should be ignored by the script running, start the file with an underscore (e.g., `_my_script.py`)
    - If the file is a library, start the file with `__lib_` (e.g., `__lib_class.py`)

## 3a. Coding Style

Adhere strictly to the project's established coding style:

- Indentation: Use 4 spaces for each level of nesting
- Naming conventions (All names must make sense when read):
   - Variables: lowercase_with_underscores
   - Functions: lowercase_with_underscores
   - Classes: CapitalizedWords
- Line length: Limit lines to 79 characters (maximum 150)
- Imports: Group imports alphabetically, separate standard library imports from project-specific ones
- Avoid unnecessary comments and print statements - Use `log.debug` instead

Example:
```python
import os

def collect_system_info() -> dict:
    """Collects system information."""
    # Main logic
    info = {'os': os.name, 'cpu_count': os.cpu_count()}
    return info

collect_system_info()
```

## 3b. Docstrings and Comments

Provide comprehensive documentation throughout your code:

- Use triple quotes for docstrings
- Explain function/class purpose, parameters, and return values
- Use inline comments sparingly to explain complex logic or non-obvious decisions

Example:
```python
def process_log_file(file_path: str) -> dict:
    """
    Processes a log file and extracts relevant information.

    Args:
        file_path (str): Path to the log file

    Returns:
        dict: Extracted log information
    """
    # We're using a try-except block here because file operations can raise exceptions
    try:
        with open(file_path, 'r') as file:
            log_content = file.read()
            # Complex parsing logic here...
            parsed_log_info = {"Parsed log information": log_content}  # Example
            return parsed_log_info
    except IOError as e:
        print(f"Error reading file: {e}")
        return {}
```

## 3c. Type Hinting

Use type hints to improve code readability and catch potential type-related bugs early:

- Use built-in types like str, int, dict, list
- For complex types, use typing module (e.g., List, Dict, Optional)
- You can also use `from __future__ import annotations` to use the `|` operator for Union types

Example:
```python
from __future__ import annotations
from typing import Dict, Optional

def analyze_process(process_id: int) -> Optional[Dict[int, int]] | None:
    """Analyzes a process and returns its details."""
    process_details = {process_id: 5}# Example
    # Process analysis logic here
    return process_details

analyze_process(123)
```

## 4. Functions and Modularity

Organize your code into reusable functions and modules:

- Keep functions focused on a single responsibility
- Use descriptive names for functions and variables
- Group related functionality into modules

Example structure:
```
Logicytics/
â””â”€â”€ CODE/
    â””â”€â”€ # Normal CODE #
â””â”€â”€ MODS/
    â””â”€â”€ # CODE for MODS #
```

## 5a. Error Handling

Implement robust error handling throughout your code:

- Use specific exception types where possible
- Provide meaningful error messages
- Handle potential exceptions gracefully
  - Don't use print - Use `log.error`, `log.warning` instead

Example:
```python
import socket
from __lib_class import *

if __name__ == "__main__":
    log = Log({"log_level": DEBUG})

def collect_network_stats():
    try:
        # Network operations here
        network_stats = {"network": "stats"}  # Example
        log.info("Network stats collected successfully.")
        return network_stats
    except socket.timeout:
        log.error("Network timeout occurred. Retrying...")
        return collect_network_stats()
    except PermissionError:
        log.error("Insufficient permissions to access network information.")
        return None
```

## 5b. Log Printing Rules

Consistent logging and output formatting are essential for debugging and monitoring. Here are the rules:

- **Python Users**: Utilize in built class `__lib_class.py` for coloured output and structured logging. Avoid using `print()` directly; reserve it for newline characters, use log.###() .
- **Other Languages**: Start messages with appropriate keywords (`INFO:`, `WARNING:`, `ERROR:`, `CRITICAL:`) followed by the message. For example, `"INFO: Your Message"`.

## 6. Follow Model Files

Use  `MOD_EXAMPLE.py` as a template for new files:

- Include proper docstrings
- Implement error handling
- Follow established coding style

## Additional Considerations

- Version control: Use Git for tracking changes
- Documentation: Update README.md and relevant documentation files
- Compatibility: Ensure new additions don't break existing features

By following these guidelines, contributors can ensure that new files integrate seamlessly
into the Logicytics project, maintaining its quality and ease of maintenance. 
Remember to run the dev (`--dev`) flag after adding new files to check for any issues and register your file.

# Logicytics Coding Tips
Here are some additional tips to help you write clean, efficient, and maintainable code for Logicytics,
These include some already made custom libraries, some special GLOBAL variables 
and some special functions that can be used to make your life easier.

## Custom scripts

### Custom LOG class
For more professionals who can understand how the project wrapper actually works,
you may utilise special mechanism's

To use Logs with its special settings, just modify the `log = Log()` line of code with any of the following parameters in dictionary format:
```python
from __lib_class import *

if __name__ == "__main__":
    log = Log({
        "filename": "../ACCESS/LOGS/Logicytics.log", # Specifies the path to the log file.
        "use_colorlog": True, # A boolean indicating whether to use colored logging output - Keep it `True`.
        "log_level": DEBUG, # Sets the logging level. Better leave it as the `DEBUG` variable.
        "debug_color": "cyan", # Color for debug messages.
        "info_color": "green", # Color for info messages.
        "warning_color": "yellow", # Color for warning messages.
        "error_color": "red", # Color for error messages.
        "critical_color": "red", # Color for critical messages.
        "exception_color": "red", # Color for exception messages.
        "colorlog_fmt_parameters": "%(log_color)s%(levelname)-8s%(reset)s %(blue)s%(message)s", # Format string for colored log messages.
    })
```

Always use the `log` object to log messages, instead of using `print()` directly.
Use the following format:
```python
from __lib_class import *

if __name__ == "__main__":
    log = Log()
```
Where `Log()` is the default settings, you can change it to your liking - Using `{"log_level": DEBUG}` etc.

### Text based logging
If for some reason you need to log something, but cant hardcode the log type, 
and must use a string for that purpose, then use the following line:

```python
from __lib_class import *

if __name__ == "__main__":
    log = Log()

log.string("MESSAGE", "LOG_TYPE")
```
Replace `MESSAGE` with the text to actually be logged
Replace `LOG_TYPE` with the following available strings (Case insensitive ðŸ¤—):

```md
"INFO": log.info
"WARNING": log.warning
"ERROR": log.error
"CRITICAL": log.critical
Anything Else: log.debug
```

**NOTE**: If the value `LOG_TYPE` is incorrect, it defaults to `info`. Might give a `Internal` warning message.

The file `_MOD_SKELETON.py` describe the use cases better, [check it out](https://github.com/DefinetlyNotAI/Logicytics/blob/main/MODS/_MOD_SKELETON.py)!

**NOTE**: Rarely does this produce `NameError` when used with [custom log classes](#custom-log-class),
but not enough tests were made to verify that. If you encounter this bug, please report it

### Create Line Separation in log
To create a new line on the log being generated, use the following code:

```python
from __lib_class import *

if __name__ == "__main__":
    log = Log()

log.newline()
```

This can work with the above two features, and doesn't actually need DEBUG to be true, 
Note however that it creates a new line with separators

## Custom Libraries

Many custom libraries are used to reduce redundancy - they are more of a local python file that is imported.
The always start with the prefix `__lib_` and are `.py` files

They hold very powerful and useful values, to learn more about their documentation, click expand:

### Library `Class`

#### Global Variables and Dictionaries

<table>
  <tr>
    <th>Variable Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>WEBHOOK</td>
    <td>WIP - The URL to send the zip files via when --webhook is called</td>
  </tr>
  <tr>
    <td>DEBUG</td>
    <td>Value from config.json - DEBUG on or off (bool)</td>
  </tr>
  <tr>
    <td>VERSION</td>
    <td>The current version of the local project</td>
  </tr>
  <tr>
    <td>API_KEY, CURRENT_FILES</td>
    <td>You may ignore these as they can't help you develop anything</td>
  </tr>
</table>

#### Custom Classes and Functions

**NOTE**: Only functions that are useful for development is shown here

<table>
  <tr>
    <th>Class.Method_Name</th>
    <th>Description</th>
    <th>Argument use case</th>
  </tr>
  <tr>
    <td>Actions.open_file(file)</td>
    <td>Opens a file or folder in default application, usually read mode, does not execute it</td>
    <td>file: str -> Relative or complete path must be used, if no file extension is given it will consider it as a directory</td>
  </tr>
  <tr>
    <td>Actions.unzip(zip_path)</td>
    <td>Unzips a ZIP file given simply</td>
    <td>zip_path: str -> Relative or complete path must be used, file extension should be `.zip` - Not really recommended to use</td>
  </tr>
  <tr>
    <td>Actions.run_command(command)</td>
    <td>Runs a command and auto parses, decodes and returns the commands value, useful to execute shell commands - Don't use this for file execution</td>
    <td>command: str -> Must be complete command like what you type on the shell itself</td>
  </tr>
  <tr>
    <td>Execute.execute_script(script)</td>
    <td>Executes the script and takes care of logging all its output, and mitigating bugs and issues, auto-parses and decodes and unblocks scripts</td>
    <td>script: str -> Only the file name or the dynamic file name and its path from the CODE directory, don't use full path's or full code.</td>
  </tr>
  <tr>
    <td>Check.uac()</td>
    <td>Checks if the UAC is disabled or not -> bool</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>Check.admin()</td>
    <td>Checks if running as admin or not -> bool</td>
    <td>N/A</td>
  </tr>
</table>


**NOTE**: We have omitted the `__lib_log.py` documentation as its from the repo [AlgoPy](https://github.com/DefinetlyNotAI/AlgoPy), 
check it out to understand more on the custom logging mechanism - Here is the direct [documentation of the class Log](https://github.com/DefinetlyNotAI/AlgoPy/blob/b72d92a047096fe99be385d81b8d5cf1fefa093b/algopy.py#L126).
This project made minor modifications on it.

# Credits

Acknowledge your contributions appropriately in the `CREDITS.md` file. 
Use the following template when asked to add your contributions in the PR:

```markdown
### File-Created/CONTRIBUTION by MAIN-Username
What you did, created, removed, refactored, fixed, or discovered.
- [Your GitHub Username](https://github.com/YourGitHubLink)
- [Your GitHub Username](https://github.com/YourGitHubLink) etc...
```

This ensures proper attribution and recognition for your efforts.

---

By following these guidelines and practices, 
you can effectively contribute to open-source projects, 
enhancing both your skills and the broader community's knowledge and tools.
