# Logicytics Contributors

Contributors are essential to the growth and success of open-source projects like Logicytics.
They come in various forms, each contributing uniquely to enhance the tool's capabilities and user experience.

## Types of Contributors

### 1. Functionality Adders

These contributors introduce new features and functionalities to Logicytics. 
Their contributions often require:

- Deep understanding of the project's architecture
- Innovative thinking to expand software capabilities
- Usually, Collaboration with existing team members to integrate new features seamlessly

Examples of contributions from Functionality Adders might include:

- Implementing new data collection modules
- Developing advanced analysis tools
- Integrating Logicytics with other popular forensic software
- Adding MODS to the project

### 2. Code Cleaners

Code cleaners focus on improving the existing Logicytics codebase. Their contributions typically involve:

- Refactoring complex code structures
- Optimizing performance-critical sections
- Ensuring adherence to Python best practices and coding standards

Code Cleaners play a crucial role in maintaining Logicytics' efficiency and maintainability over time.

### 3. QoL Enhancers

Quality of Life (QoL) enhancers focus on improving the usability and enjoyment of Logicytics 
without necessarily adding new features. Their contributions might include:

- Basic Improvements to enhance user experience
- Streamlining workflows within the application
- Maintaining a clean and intuitive GitHub repository

QoL Enhancers contribute significantly to making Logicytics more accessible and effective for its users.

### 4. Bug Fixers

Bug fixers focus on identifying and resolving issues within the Logicytics codebase. 
Their contributions are crucial for:

- Maintaining stability and reliability of the tool
- Improving overall user experience by eliminating frustrating errors
- Ensuring compatibility across different Windows versions (mostly 10 and 11) and hardware configurations
- Fixes that significantly impact overall performance or stability

### 5. Documentation Specialists

Documentation specialists focus on creating and updating comprehensive documentation for Logicytics. 
Their contributions include:

- Writing clear, concise user guides
- Updating the project's README and wiki pages on every major or minor release
- Maintaining up-to-date release notes and changelogs

Good documentation is essential for onboarding new users and facilitating collaboration among contributors.

**NOTE**: Contributors may fall into multiple categories based on their contributions (Most likely QoL Enhancers), they also may not fall into any.

### 6. Community Supporters

Community supporters contribute by engaging with other users and potential contributors. 
Their activities might include:

- Answering questions on GitHub issues or forums.
- Providing support through issues.

Community supporters help build and sustain interest in the project, 
attracting new contributors and users.

**NOTE**: Contributors may fall into multiple categories based on their contributions, they also may not fall into any.

## Contribution Tips

Logicytics welcomes contributions from individuals with various skill levels and backgrounds. To contribute:

1. Fork the repository on GitHub
2. Choose an area you'd like to contribute to (new feature, bug fix, etc.)
3. Make your changes and commit them
4. Open a pull request describing your contribution
5. Engage with the review process and address any feedback

Remember to follow the project's contributing guidelines and code of conduct when making contributions.

Contributors who wish to register their contributions properly should use the `--dev` flag 
when running Logicytics. 
This ensures proper attribution and tracking of contributions within the project's ecosystem.
Then just follow the instructions [below](#how-to-contribute) to get more specific details.

## How to Contribute

Contributing to open-source projects is a rewarding way to give back to the community
while enhancing your skills. Here's how you can get started:

1. **Fork the Repository**: Visit the project's GitHub page and click on the 'Fork' button in the top right corner. This creates a copy of the repository in your GitHub account.

2. **Clone the Repository**: Clone the forked repository to your local machine using Git. Open your terminal or command prompt and run:
   ```bash
   git clone https://github.com/DefinetlyNotAI/Logicytics.git
   ```
3. **Create a New Branch**: It's good practice to create a new branch for your changes. This keeps the main branch clean and makes merging easier. Run:
   ```bash
   git checkout -b feature/your-feature-description
   ```
   Replace `your-feature-description` with your feature description.

4. **Make Your Changes**: Navigate through the files and make your contributions. Remember to adhere to the project's coding standards and practices outlined below.

5. **Commit Your Changes**: After making your changes, stage them for commit. Then, commit with a meaningful message:
   ```bash
   git add.
   git commit -m "Your descriptive commit message"
   ```

6. **Push Your Changes**: Push your committed changes to your forked repository on GitHub:
   ```bash
   git push origin feature/your-feature-description
   ```

7. **Open a Pull Request (PR)**: Go to your forked repository on GitHub, switch to your feature branch, and click 'New pull request'. Fill out the form, describing your changes and why they should be included. Submit the PR for review.

# Logicytics Coding Standards

## Table of Contents

1. [Introduction](#1-introduction)
2. [Language Preference](#2-language-preference)
3. [File Naming and Organization](#3-file-naming-and-organization)
4. [Coding Style](#4-coding-style)
5. [Functions and Modularity](#5-functions-and-modularity)
6. [Log Handling](#6-log-handling)
7. [Version Control](#7-version-control)
8. [Documentation](#8-documentation)
9. [Compatibility](#9-compatibility)
10. [Security Considerations](#10-security-considerations)
11. [Code Review Process](#11-code-review-process)
12. [Version control](#12-version-control-and-branching-strategy)
13. [Dependency Management](#13-dependency-management)
14. [Conclusion](#14-conclusion)

## 1. Introduction

Logicytics Coding Standards are designed to ensure consistency, readability, 
and maintainability throughout our codebase. These standards are crucial 
for collaborative development and long-term maintenance of Logicytics projects. Adhering
to these practices ensures that our codebase remains clean, 
efficient, and easy to understand for all contributors.

## 2. Language Preference

Prefer Python, Batch, or PowerShell scripts for new additions:

- **Python**: Ideal for complex logic and integrations
- **Batch**: Suitable for simple Windows-specific tasks
- **PowerShell**: Good for advanced Windows automation

If using other languages:
- Ensure thorough documentation
- Translate to EXE for compatibility

## 3. File Naming and Organization

Follow these guidelines:

### 3a. Directory Structure

- Place files in appropriate directories based on functionality
- Example structure:

```
Logicytics/
└── CODE/
|   └── # Normal CODE #
└── MODS/
    └── # CODE for MODS #
```

### 3b. File Naming Conventions

- Use `lowercase_with_underscores` naming convention (e.g., `my_script.py`)
    - If the file should be ignored by the script running, start the file with an underscore (e.g., `_my_script.py`)
    - If the file is a library, start the file with `__lib_` (e.g., `__lib_class.py`)

## 4. Coding Style

### 4a. General Guidelines

- Indentation: Use 4 spaces for each level of nesting
- Naming conventions:
    - Variables: `lowercase_with_underscores`
    - Functions/Methods: `lowercase_with_underscores`
    - Classes: `CapitalizedWords`
- Line length: Limit lines to 79 characters (maximum 150)
- Imports: Group imports alphabetically, separate standard library imports from project-specific ones
- Avoid unnecessary comments and print statements - Use `log.debug()` and `log.info()` instead of `print()`

Example:
```python
import os
from typing import Dict, Any
import psutil
import json

def collect_system_info() -> Dict[str, Any]:
    """Collects system information."""
    # Main logic
    info = {
        'os': os.name,
        'cpu_count': os.cpu_count(),
        'memory': psutil.virtual_memory().total / (1024 * 1024),
        'disk_space': psutil.disk_usage('/').total / (1024 * 1024)
    }
    return info

if __name__ == "__main__":
    system_info = collect_system_info()
    print(json.dumps(system_info, indent=2))
```

### 4b. Docstrings and Comments

- Use triple quotes for docstrings
- Explain function/class purpose, parameters, and return values
- Use inline comments sparingly to explain complex logic or non-obvious decisions

Example:

```python
from typing import Dict, Any, List
from __lib_class import *

if __name__ == "__main__":
    log = Log({"log_level": DEBUG})


def process_log_file(file_path: str) -> Dict[str, Any]:
    """
    Processes a log file and extracts relevant information.

    Args:
        file_path (str): Path to the log file

    Returns:
        Dict[str, Any]: Extracted log information

    Raises:
        IOError: If the file cannot be read
        ValueError: If the file content is invalid
    """
    # We're using a try-except block here because file operations can raise exceptions
    try:
        with open(file_path, 'r') as file:
            file.read()
            # Complex parsing logic here...
            parsed_log_info = parse_log_content()
            return {"file_path": file_path, "content": parsed_log_info}
    except IOError as e:
        log.error(f"Error reading file: {e}")
        raise
    except ValueError as e:
        log.warning(f"Invalid file content: {e}")
        return {}


def parse_log_content() -> List[Dict[str, str]]:
    """Parses log content and returns structured data."""
    # Implementation details...
    pass
```

### 4c. Type Hinting

- Use built-in types like `str`, `int`, `dict`, `list`
- For complex types, use `typing` module (e.g., `List`, `Dict`, `Optional`)
- You can also use `from __future__ import annotations` to use the `|` operator for Union types

Example:
```python
from __future__ import annotations
from typing import Dict, Optional, Any, Tuple

def analyze_process(process_id: int) -> Optional[Tuple[int, Dict[str, float]]] | None:
    """Analyzes a process and returns its details."""
    process_details = get_process_details(process_id)
    if not process_details:
        return None
    cpu_usage, memory_usage = calculate_resource_usage(process_details)
    return process_id, {'cpu': cpu_usage, 'memory': memory_usage}

def get_process_details(process_id: int) -> Optional[Dict[str, Any]]:
    """Retrieves process details."""
    # Implementation details...
    return {'Process ID': process_id}

def calculate_resource_usage(details: Dict[str, Any]) -> Tuple[float, float]:
    """Calculates CPU and memory usage based on process details."""
    # Implementation details...
    return details['cpu_usage'], details['memory_usage']
```

## 5. Functions and Modularity

- Keep functions focused on a single responsibility
- Use descriptive names for functions and variables
- Group related functionality into modules
- Aim for a maximum of 20-30 lines per function
- Use meaningful parameter names and avoid excessive parameters (>4)

Example:
```python
import os
from datetime import datetime
import zipfile

def create_backup(Source_dir: str, backup_dir: str) -> str:
    """Creates a backup of the source directory."""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    Backup_name = f"{os.path.basename(Source_dir)}_{timestamp}.zip"
    backup_path = os.path.join(backup_dir, Backup_name)
    
    zip_files(Source_dir, Backup_path)
    return backup_path

def zip_files(source: str, destination: str) -> None:
    """Zips files from source to destination."""
    with zipfile.ZipFile(destination, 'w', compression=zipfile.ZIP_DEFLATED) as zipf:
        for root, _, files in os.walk(source):
            for file in files:
                file_path = os.path.join(root, file)
                rel_path = os.path.relpath(file_path, source)
                zipf.write(file_path, rel_path)

def verify_backup(backup_path: str) -> bool:
    """Verifies the integrity of a backup file."""
    try:
        with zipfile.ZipFile(backup_path, 'r') as zip_ref:
            zip_ref.testzip()
        return True
    except zipfile.BadZipFile:
        return False

# Usage
source_dir = "/path/to/source"
Backup_dir = "/path/to/backups"

Backup_path = create_backup(source_dir, Backup_dir)
if verify_backup(Backup_path):
    print(f"Backup created successfully: {Backup_path}")
else:
    print("Backup verification failed.")
```

## 6. Log Handling

### 6a. General Error Handling

- Use specific exception types where possible
- Provide meaningful error messages
- Handle potential exceptions gracefully
    - Don't use `print()` - Use `log.error()`, `log.warning()` and `log.critical()` instead
    - To raise exceptions, use `log.exception()` with your message and Exception class type, like `log.exception("Error Message", FileNotFoundError)`

Example:
```python
import socket
from typing import Dict, Any
from __lib_class import *

if __name__ == "__main__":
    log = Log({"log_level": DEBUG})

def collect_network_stats():
    try:
        # Network operations here
        network_stats = {"network": "stats"}  # Example
        log.info("Network stats collected successfully.")
        return network_stats
    except socket.timeout:
        log.error("Network timeout occurred. Retrying...")
        return collect_network_stats()
    except PermissionError:
        log.error("Insufficient permissions to access network information.")
        return None
    except Exception as e:
        log.critical(f"Unexpected error occurred: {e}")
        raise

def process_user_input(input_data: str) -> Dict[str, Any]:
    """Processes user input and returns structured data."""
    try:
        parsed_input = parse_input(input_data)
        validated_data = validate_input(parsed_input)
        processed_result = process_validated_data(validated_data)
        log.debug(f"Processed input: {input_data}")
        return {"status": "success", "result": processed_result}
    except ValueError as e:
        log.warning(f"Invalid input: {e}")
        return {"status": "error", "message": str(e)}
    except Exception as e:
        log.exception(f"Unexpected error during input processing: {e}", Exception)
        raise

def parse_input(input_data: str) -> Dict[str, Any]:
    """Parses raw input into structured data."""
    # Implementation details...
    return {"parsed_data": input_data}

def validate_input(parsed_data: Dict[str, Any]) -> Dict[str, Any]:
    """Validates parsed input data."""
    # Implementation details...
    return {"validated_data": parsed_data}

def process_validated_data(validated_data: Dict[str, Any]) -> Dict[str, Any]:
    """Processes validated input data."""
    # Implementation details...
    return {"processed_data": validated_data}
```

### 6b. Log Printing Rules

- **Python Users**: Utilize in-built class `__lib_class.py` for colored output and structured logging. Avoid using `print()`; for newline characters, use `log.newline()` instead.
- **Other Languages**: Start messages with appropriate keywords (`INFO:`, `WARNING:`, `ERROR:`, `CRITICAL:`) followed by the message. For example, `"INFO: Your Message"`.

## 7. Version Control

- Use Git for tracking changes
- Create feature branches for new features or bug fixes
- Use descriptive commit messages following the Conventional Commits format
- Include relevant issue numbers in commit messages when applicable

Example commit message:
```
feat: add support for multi-threaded processing

- Implement ThreadPoolExecutor for parallel task execution
- Add configuration option for thread count
- Update documentation with usage examples

Closes #123
```

## 8. Documentation

### 8a. Project-Level Documentation

- Maintain an up-to-date `README.md` file in the project root
- Include information about:
    - Project overview
    - Installation instructions
    - Usage examples
    - Contributing guidelines
    - License information

Example `README.md` structure:

```markdown
# Logicytics Project

A comprehensive toolkit for system analysis and automation.

## Table of Contents

- [Installation](#installation)
- [Usage](#usage)
- [Contributing](#contributing)
- [License](#license)

## Installation

To install Logicytics, follow these steps:
`git clone https://github.com/DefinetlyNotAI/Logicytics.git`
`pip install -r requirements.txt`

## Usage

Basic usage example:

"""
from logicytics import SystemAnalyzer

analyzer = SystemAnalyzer()
report = analyzer.generate_report()
print(report.summary())
"""

## Contributing

See our [CONTRIBUTING.md](CONTRIBUTING.md) file for details on how to contribute.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
```

### 8b. Module and Function Documentation

- Use docstrings for all modules, classes, functions, and methods
- Follow the Google Python Style Guide for docstring formatting
- Include information about parameters, return values, exceptions raised, and any side effects

Example module documentation:

```python
"""
Module for handling network-related operations.

Classes:
    NetworkInterface: Represents a network interface.
    PacketSniffer: Sniffs packets on a given interface.

Functions:
    get_network_interfaces(): Returns a list of available network interfaces.
    ping_host(host: str): Pings a host and returns the result.
"""

from typing import List


class NetworkInterface:
    """Represents a network interface."""

    def __init__(self, name: str):
        """
        Initializes a NetworkInterface object.

        Args:
            name (str): Name of the network interface.
        """
        self.name = name

    def get_ip_address(self) -> str:
        """
        Gets the IP address associated with this interface.

        Returns:
            str: The IP address of the interface.

        Raises:
            ValueError: If the interface doesn't have an IP address assigned.
        """
        # Implementation details...


def get_network_interfaces() -> List[NetworkInterface]:
    """
    Retrieves a list of available network interfaces.

    Returns:
        List[NetworkInterface]: A list of NetworkInterface objects representing available interfaces.
    """
    # Implementation details...


def ping_host() -> bool:
    """
    Pings a host and returns the result.

    Returns:
        bool: True if the host responds, False otherwise.

    Raises:
        socket.error: If there's a problem with the network connection.
    """
    # Implementation details...
```

### 8c. Inline Comments

- Use inline comments sparingly to explain complex logic or non-obvious decisions
- Keep comments concise and relevant
- Update comments when modifying code to ensure they remain accurate

Example:

```python
import zlib
from typing import Dict, Any
import json


def calculate_checksum(data: bytes) -> int:
    """
    Calculates the checksum of the given data using CRC32 algorithm.

    Args:
        data (bytes): Data to calculate checksum for.

    Returns:
        int: The calculated checksum.
    """
    # We're using zlib.crc32 here because it provides a fast and reliable CRC32 implementation
    return zlib.crc32(data) & 0xffffffff

def parse_config(config_str: str) -> Dict[str, Any]:
    """
    Parses a configuration string into a dictionary.

    Args:
        config_str (str): Configuration string in JSON format.

    Returns:
        Dict[str, Any]: Parsed configuration dictionary.

    Raises:
        json.JSONDecodeError: If the input string is not valid JSON.
    """
    # We're using json.loads instead of eval for security reasons
    # It safely parses JSON strings without executing arbitrary code
    return json.loads(config_str)
```

## 9. Compatibility

- Ensure new additions don't break existing features
- Use version control tags to mark major releases
- Implement backwards compatibility for at least one minor version
- Document any breaking changes in release notes

Example of documenting breaking changes:

### Breaking Changes

1. Removed deprecated `old_function()` method. Use `new_method()` instead.
2. Changed default behavior of `process_data()`. Now requires explicit `verbose=False` parameter for silent operation.

### New Features

- Added support for parallel processing in `analyze_system()`
- Introduced new `config_manager` class for centralized configuration management

### Bug Fixes

- Fixed issue with incorrect timestamp parsing in `parse_log_file()`
- Resolved memory leak in `continuous_monitoring()` function

## 10. Security Considerations

### 10a. Input Validation

- Always validate and sanitize user inputs
- Use whitelisting approach for allowed inputs
- Implement proper error handling for invalid inputs

Example:

```python
import re
import bcrypt

def validate_username(username: str) -> bool:
    """
    Validates a username against security criteria.

    Args:
        username (str): Username to validate.

    Returns:
        bool: True if the username is valid, False otherwise.
    """
    pattern = r'^[a-zA-Z0-9_]{3,16}$'
    return bool(re.match(pattern, username))

def create_user(username: str, password: str) -> dict:
    """
    Creates a new user account.

    Args:
        username (str): Desired username.
        password (str): Password for the new account.

    Returns:
        User: Created user object if successful, None otherwise.

    Raises:
        ValueError: If the username or password is invalid.
    """
    if not validate_username(username):
        raise ValueError("Invalid username")
    
    if len(password) < 8:
        raise ValueError("Password must be at least 8 characters long")

    # Hash password before storing
    hashed_password = hash_password(password)
    return {username: hashed_password}

def hash_password(password: str) -> str:
    """
    Hashes a password using bcrypt.

    Args:
        password (str): Password to hash.

    Returns:
        str: Hashed password string.
    """
    salt = bcrypt.gensalt()
    return str(bcrypt.hashpw(password.encode(), salt))
```

### 10b. Secure Data Handling

- Use secure methods for data encryption and decryption
- Implement proper key management practices
- Avoid hardcoding sensitive information in source code

Example:

```python
from cryptography.fernet import Fernet

class SecureDataHandler:
    def __init__(self, key: str):
        self.key = key.encode()

    def encrypt_data(self, data: str) -> str:
        """
        Encrypts the given data using Fernet symmetric encryption.

        Args:
            data (str): Data to encrypt.

        Returns:
            str: Encrypted data as a URL-safe base64-encoded string.
        """
        cipher_suite = Fernet(self.key)
        cipher_text = cipher_suite.encrypt(data.encode())
        return cipher_text.decode()

    def decrypt_data(self, encrypted_data: str) -> str:
        """
        Decrypts the given encrypted data.

        Args:
            encrypted_data (str): Encrypted data to decrypt.

        Returns:
            str: Decrypted data.

        Raises:
            ValueError: If the decryption fails.
        """
        try:
            cipher_suite = Fernet(self.key)
            plain_text = cipher_suite.decrypt(encrypted_data.encode())
            return plain_text.decode()
        except Exception as e:
            raise ValueError(f"Decryption failed: {e}")

# Usage example
handler = SecureDataHandler(str(Fernet.generate_key()))
secret_message = "This is a secret message"
encrypted_message = handler.encrypt_data(secret_message)
decrypted_message = handler.decrypt_data(encrypted_message)

assert secret_message == decrypted_message
```

## 11. Code Review Process

### 11a. Pre-Review Checklist

Before submitting code for review:

1. Run linters and formatters (`black .`)
2. Perform manual testing of new functionality
3. Update documentation
4. Ensure code adheres to coding standards

### 11b. Review Guidelines

During code review:

1. Focus on code quality, readability, and maintainability
2. Check for adherence to coding standards
3. Evaluate performance implications
4. Assess security aspects
5. Look for opportunities for refactoring or optimization

Example code review checklist:

```markdown
# Code Review Checklist

## General
- Does the code follow Logicytics Coding Standards?
- Are all functions/classes properly documented?

## Performance
- Are there any obvious performance bottlenecks?
- Is memory usage optimized?

## Security
- Are inputs properly validated and sanitized?
- Are sensitive data handled securely?

## Testing
- Are appropriate unit tests included?
- Do tests cover edge cases?

## Architecture
- Does the code fit well with the overall project architecture?
- Are dependencies properly managed?

## Readability
- Is the code easy to understand?
- Are variable/function names descriptive?

## Comments
- Are comments clear and concise?
- Are complex logic parts commented?

## Error Handling
- Are exceptions handled appropriately?
- Are error messages informative?

## Documentation
- Is the README updated if necessary?
- Are any new APIs or interfaces documented?

## Best Practices
- Are design patterns used appropriately?
- Is the code DRY (Don't Repeat Yourself)?

## Suggestions
- Any suggestions for improvement or refactoring?
```

## 12. Version Control and Branching Strategy

### 12a. Git Workflow

Adopt the Git Flow branching model:

1. `main`: Production-ready branch
2. `develop`: Main development branch
3. Feature branches: `feature-*`
4. Release branches: `release-*`
5. Hotfix branches: `hotfix-*`

Example Git commands:

```bash
# Create feature branch
git checkout -b feature/new-login-system develop

# Commit changes
git commit -am "Implement new login system"

# Push feature branch
git push origin feature/new-login-system

# Create pull request for review

# After approval and merge
git checkout develop
git merge --no-ff feature/new-login-system
git push origin develop

# Delete feature branch
git branch -d feature/new-login-system
```

### 12b. Commit Messages

Follow the Conventional Commits specification:

```text
[type]([optional scope]): [description]

[body]

[footer]
```

Example of a great commit messages:

```text
feat(auth): implement OAuth2 login

Add OAuth2 authentication flow for users

BREAKING CHANGE: Removes old session-based auth

fix(db): resolve connection pooling issue

Improve database connection handling to prevent timeouts

docs(readme): update installation instructions

Update README.md with latest setup steps

refactor(core): optimize system monitoring loop

Reduce CPU usage in system monitoring function

perf(api): improve response time for large datasets

Implement caching mechanism for API responses

test(utils): add unit tests for helper functions

Add comprehensive test suite for utility functions

chore(ci): update GitHub Actions workflow

Upgrade CI pipeline to use Python 3.9

style(formatter): fix linting issues

Run Black formatter on entire codebase
```

## 13. Dependency Management

### 13a. Package Version Control

Use semantic versioning for Logicytics packages:

- MAJOR.MINOR.PATCH format
- Increment MAJOR for breaking changes
- Increment MINOR for new features
- Increment PATCH for bug fixes


### 13b. Dependency Security

Implement dependency security checks:

1. Use tools like `pip-compile` or `poetry` for dependency management
2. Regularly update dependencies
3. Scan for known vulnerabilities

## 14. Conclusion

The Logicytics Coding Standards document provides a comprehensive guide for developing high-quality,
maintainable, and secure software. By following these guidelines, 
developers can ensure consistency across projects, improve code readability, 
and reduce potential bugs and security vulnerabilities.

Remember to regularly review and update these standards to reflect best practices and new technologies.
Encourage team members to contribute to the evolution 
of these standards through continuous feedback and discussion.

By adhering to these coding standards, 
Logicytics aims to deliver exceptional software solutions 
while fostering a culture of excellence in software engineering.

This concludes the Logicytics Coding Standards document. 
Remember to adapt and expand these standards as needed for your specific projects 
and organizational requirements.

---

# Logicytics Coding Tips
Here are some additional tips to help you write clean, efficient, and maintainable code for Logicytics,
These include some already made custom libraries, some special GLOBAL variables 
and some special functions that can be used to make your life easier.

## Custom scripts

### Custom LOG class
For more professionals who can understand how the project wrapper actually works,
you may utilise special mechanism's

To use Logs with its special settings, just modify the `log = Log()` line of code with any of the following parameters in dictionary format:
```python
from __lib_class import *

if __name__ == "__main__":
    log = Log({
        "filename": "../ACCESS/LOGS/Logicytics.log", # Specifies the path to the log file.
        "use_colorlog": True, # A boolean indicating whether to use colored logging output - Keep it `True`.
        "log_level": DEBUG, # Sets the logging level. Better leave it as the `DEBUG` variable.
        "debug_color": "cyan", # Color for debug messages.
        "info_color": "green", # Color for info messages.
        "warning_color": "yellow", # Color for warning messages.
        "error_color": "red", # Color for error messages.
        "critical_color": "red", # Color for critical messages.
        "exception_color": "red", # Color for exception messages.
        "colorlog_fmt_parameters": "%(log_color)s%(levelname)-8s%(reset)s %(blue)s%(message)s", # Format string for colored log messages.
    })
```

Always use the `log` object to log messages, instead of using `print()` directly.
Use the following format:
```python
from __lib_class import *

if __name__ == "__main__":
    log = Log()
```
Where `Log()` is the default settings, you can change it to your liking - Using `{"log_level": DEBUG}` etc.

### Text based logging
If for some reason you need to log something, but cant hardcode the log type, 
and must use a string for that purpose, then use the following line:

```python
from __lib_class import *

if __name__ == "__main__":
    log = Log()

log.string("MESSAGE", "LOG_TYPE")
```
Replace `MESSAGE` with the text to actually be logged
Replace `LOG_TYPE` with the following available strings (Case insensitive 🤗):

```md
"INFO": log.info
"WARNING": log.warning
"ERROR": log.error
"CRITICAL": log.critical
Anything Else: log.debug
```

**NOTE**: If the value `LOG_TYPE` is incorrect, it defaults to `info`. Might give a `Internal` warning message.

The file `_MOD_SKELETON.py` describe the use cases better, [check it out](https://github.com/DefinetlyNotAI/Logicytics/blob/main/MODS/_MOD_SKELETON.py)!

**NOTE**: Rarely does this produce `NameError` when used with [custom log classes](#custom-log-class),
but not enough tests were made to verify that. If you encounter this bug, please report it

### Create Line Separation in log
To create a new line on the log being generated, use the following code:

```python
from __lib_class import *

if __name__ == "__main__":
    log = Log()

log.newline()
```

This can work with the above two features, and doesn't actually need DEBUG to be true, 
Note however that it creates a new line with separators

## Custom Libraries

Many custom libraries are used to reduce redundancy - they are more of a local python file that is imported.
The always start with the prefix `__lib_` and are `.py` files

They hold very powerful and useful values, to learn more about their documentation, click expand:

### Library `Class`

#### Global Variables and Dictionaries

<table>
  <tr>
    <th>Variable Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>WEBHOOK</td>
    <td>WIP - The URL to send the zip files via when --webhook is called</td>
  </tr>
  <tr>
    <td>DEBUG</td>
    <td>Value from config.json - DEBUG on or off (bool)</td>
  </tr>
  <tr>
    <td>VERSION</td>
    <td>The current version of the local project</td>
  </tr>
  <tr>
    <td>API_KEY, CURRENT_FILES</td>
    <td>You may ignore these as they can't help you develop anything</td>
  </tr>
</table>

#### Custom Classes and Functions

**NOTE**: Only functions that are useful for development is shown here

<table>
  <tr>
    <th>Class.Method_Name</th>
    <th>Description</th>
    <th>Argument use case</th>
  </tr>
  <tr>
    <td>Actions.open_file(file)</td>
    <td>Opens a file or folder in default application, usually read mode, does not execute it</td>
    <td>file: str -> Relative or complete path must be used, if no file extension is given it will consider it as a directory</td>
  </tr>
  <tr>
    <td>Actions.unzip(zip_path)</td>
    <td>Unzips a ZIP file given simply</td>
    <td>zip_path: str -> Relative or complete path must be used, file extension should be `.zip` - Not really recommended to use</td>
  </tr>
  <tr>
    <td>Actions.run_command(command)</td>
    <td>Runs a command and auto parses, decodes and returns the commands value, useful to execute shell commands - Don't use this for file execution</td>
    <td>command: str -> Must be complete command like what you type on the shell itself</td>
  </tr>
  <tr>
    <td>Execute.execute_script(script)</td>
    <td>Executes the script and takes care of logging all its output, and mitigating bugs and issues, auto-parses and decodes and unblocks scripts</td>
    <td>script: str -> Only the file name or the dynamic file name and its path from the CODE directory, don't use full path's or full code.</td>
  </tr>
  <tr>
    <td>Check.uac()</td>
    <td>Checks if the UAC is disabled or not -> bool</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>Check.admin()</td>
    <td>Checks if running as admin or not -> bool</td>
    <td>N/A</td>
  </tr>
</table>


**NOTE**: We have omitted the `__lib_log.py` documentation as its from the repo [AlgoPy](https://github.com/DefinetlyNotAI/AlgoPy), 
check it out to understand more on the custom logging mechanism - Here is the direct [documentation of the class Log](https://github.com/DefinetlyNotAI/AlgoPy/blob/b72d92a047096fe99be385d81b8d5cf1fefa093b/algopy.py#L126).
This project made minor modifications on it.

# Credits

Acknowledge your contributions appropriately in the `CREDITS.md` file. 
Use the following template when asked to add your contributions in the PR:

```markdown
### File-Created/CONTRIBUTION by MAIN-Username
What you did, created, removed, refactored, fixed, or discovered.
- [Your GitHub Username](https://github.com/YourGitHubLink)
- [Your GitHub Username](https://github.com/YourGitHubLink) etc...
```

This ensures proper attribution and recognition for your efforts.

---

By following these guidelines and practices, 
you can effectively contribute to open-source projects, 
enhancing both your skills and the broader community's knowledge and tools.
